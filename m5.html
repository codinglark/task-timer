<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Timer</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        function TaskTimer() {
            const stateFromTitlesOnly = (titles, title = "Task Timer") => ({
                title,
                tasks: titles.map((name, index) => ({
                    id: index + 1, name, completed: false, Active: 0, Idle: 0, position: index
                })),
                currentTaskId: 1,
                currentInterval: null
            });

            const updatePositions = (tasks) => 
                tasks.map((task, index) => ({ ...task, position: index }));

            const stateFromString = (stateString) => {
                const defaultTitles = ['Task 1', 'Task 2', 'Task 3'];
                if (!stateString.trim()) return stateFromTitlesOnly(defaultTitles);
                
                try {
                    const state = JSON.parse(atob(stateString));
                    return { ...state, tasks: updatePositions(state.tasks) };
                } catch {
                    // Simple encoding: check for title prefix
                    const lines = stateString.split('\n').map(line => line.trim()).filter(line => line !== '');
                    
                    let title = ""; // Default to empty string for simple imports
                    let taskLines = lines;
                    
                    if (lines.length > 0 && lines[0].startsWith('title: ')) {
                        title = lines[0].substring(7); // Remove "title: " prefix
                        taskLines = lines.slice(1);
                    }
                    
                    if (taskLines.length === 0 || taskLines.length > 100 || taskLines.some(name => name.length > 512)) {
                        throw new Error('Invalid format');
                    }
                    
                    return stateFromTitlesOnly(taskLines, title);
                }
            };

            const [title, setTitle] = useState("Task Timer");
            const [tasks, setTasks] = useState([]);
            const [currentTime, setCurrentTime] = useState(Date.now());
            const [editingTask, setEditingTask] = useState(null);
            const [editingValue, setEditingValue] = useState('');
            const [editingTitle, setEditingTitle] = useState(false);
            const [editingTitleValue, setEditingTitleValue] = useState('');
            const [importFeedback, setImportFeedback] = useState('');
            const [importText, setImportText] = useState('');
            const [reorderingTasks, setReorderingTasks] = useState(new Set());
            const [showSlots, setShowSlots] = useState(false);
            const [currentSlot, setCurrentSlot] = useState(1);
            
            const [currentInterval, setCurrentInterval] = useState(null); // {start: timestamp, type: 'Active'|'Idle', taskId: number}
            const [currentTaskId, setCurrentTaskId] = useState(1);

            // localStorage functions for 5-slot system
            const saveToStorage = (state, slotId = currentSlot) => {
                try {
                    const stateToSave = {
                        title: state.title,
                        tasks: state.tasks.map(({position, ...task}) => task), // Strip position fields
                        currentTaskId: state.currentTaskId,
                        currentInterval: state.currentInterval,
                        savedAt: new Date().toISOString()
                    };
                    
                    // Load existing slots
                    const slots = JSON.parse(localStorage.getItem('taskTimerSlots') || '{}');
                    slots[slotId] = stateToSave;
                    
                    localStorage.setItem('taskTimerSlots', JSON.stringify(slots));
                    localStorage.setItem('taskTimerCurrentSlot', slotId.toString());
                } catch (error) {
                    console.warn('Failed to save to localStorage:', error);
                }
            };

            const loadFromStorage = (slotId = null) => {
                try {
                    // Determine which slot to load
                    const targetSlot = slotId || localStorage.getItem('taskTimerCurrentSlot') || '1';
                    const slots = JSON.parse(localStorage.getItem('taskTimerSlots') || '{}');
                    const saved = slots[targetSlot];
                    
                    if (!saved) return null;
                    
                    return {
                        ...saved,
                        tasks: updatePositions(saved.tasks)
                    };
                } catch (error) {
                    console.warn('Failed to load from localStorage:', error);
                    return null;
                }
            };

            const getAllSlots = () => {
                try {
                    const slots = JSON.parse(localStorage.getItem('taskTimerSlots') || '{}');
                    return [1, 2, 3, 4, 5].map(i => ({
                        id: i,
                        data: slots[i] || null
                    }));
                } catch (error) {
                    console.warn('Failed to load slots:', error);
                    return [1, 2, 3, 4, 5].map(i => ({ id: i, data: null }));
                }
            };

            const deleteAllAppState = () => {
                localStorage.removeItem('taskTimerSlots');
                localStorage.removeItem('taskTimerCurrentSlot');
                // Reset to fresh app state
                const defaultState = stateFromString('');
                setTitle(defaultState.title);
                setTasks(defaultState.tasks);
                setCurrentTaskId(defaultState.currentTaskId);
                setCurrentInterval(null);
                setCurrentSlot(1);
                setCurrentTime(Date.now());
                setShowSlots(false);
            };

            const switchToSlot = (slotId) => {
                // Save current state to current slot first
                saveToStorage({ title, tasks, currentTaskId, currentInterval }, currentSlot);
                
                // Load the target slot
                setCurrentSlot(slotId);
                const savedState = loadFromStorage(slotId.toString());
                
                if (savedState) {
                    setTitle(savedState.title || "Task Timer");
                    setTasks(savedState.tasks);
                    setCurrentTaskId(savedState.currentTaskId);
                    setCurrentInterval(savedState.currentInterval);
                } else {
                    // Empty slot, use defaults
                    const defaultState = stateFromString('');
                    setTitle(defaultState.title);
                    setTasks(defaultState.tasks);
                    setCurrentTaskId(defaultState.currentTaskId);
                    setCurrentInterval(defaultState.currentInterval);
                }
                setCurrentTime(Date.now());
                setShowSlots(false);
            };

            // Update current time every 100ms when interval is running  
            useEffect(() => {
                if (!currentInterval) return;
                const timer = setInterval(() => setCurrentTime(Date.now()), 100);
                return () => clearInterval(timer);
            }, [currentInterval]);

            const handleInputRef = useCallback((input) => {
                if (input) {
                    input.select();
                }
            }, []);

            // Load saved state on mount
            useEffect(() => {
                const currentSlotId = parseInt(localStorage.getItem('taskTimerCurrentSlot') || '1');
                setCurrentSlot(currentSlotId);
                
                const savedState = loadFromStorage(currentSlotId.toString());
                if (savedState) {
                    setTitle(savedState.title || "Task Timer");
                    setTasks(savedState.tasks);
                    setCurrentTaskId(savedState.currentTaskId);
                    setCurrentInterval(savedState.currentInterval);
                } else {
                    // No saved state, use defaults
                    const defaultState = stateFromString('');
                    setTitle(defaultState.title);
                    setTasks(defaultState.tasks);
                    setCurrentTaskId(defaultState.currentTaskId);
                    setCurrentInterval(defaultState.currentInterval);
                }
                setCurrentTime(Date.now());
            }, []);

            // Auto-save whenever state changes
            useEffect(() => {
                const currentState = {
                    title,
                    tasks,
                    currentTaskId,
                    currentInterval
                };
                saveToStorage(currentState, currentSlot);
            }, [title, tasks, currentTaskId, currentInterval, currentSlot]);

            const getTaskTime = (task, mode) => {
                const baseTime = task[mode];
                const isRunning = currentInterval?.taskId === task.id && currentInterval.type === mode;
                const runningTime = isRunning ? currentTime - currentInterval.start : 0;
                return {
                    time: baseTime + runningTime,
                    isRunning
                };
            };

            const getTotals = () => {
                const totals = tasks.reduce((acc, task) => {
                    const active = getTaskTime(task, 'Active');
                    const idle = getTaskTime(task, 'Idle');
                    return {
                        Active: acc.Active + active.time,
                        Idle: acc.Idle + idle.time
                    };
                }, { Active: 0, Idle: 0 });
                
                const allCompleted = tasks.every(task => task.completed);
                return { ...totals, allCompleted };
            };

            const formatTime = (ms) => {
                const seconds = Math.floor(ms / 1000);
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const changeIntervalTo = (newState) => {
                const now = Date.now();
                setCurrentTime(now);
                
                // Skip if same task and mode
                if (currentInterval && newState && 
                    currentInterval.taskId === newState.taskId && 
                    currentInterval.type === newState.mode) {
                    return;
                }
                
                // Close current interval
                if (currentInterval) {
                    const duration = now - currentInterval.start;
                    setTasks(prev => prev.map(task => 
                        task.id === currentInterval.taskId 
                            ? { ...task, [currentInterval.type]: task[currentInterval.type] + duration }
                            : task
                    ));
                }
                
                // Start new interval
                setCurrentInterval(newState && newState.taskId ? {
                    start: now,
                    type: newState.mode,
                    taskId: newState.taskId
                } : null);
            };

            const completeTask = (taskId, completed = true) => {
                // Calculate updated tasks and find first incomplete
                const updatedTasks = tasks.map(task =>
                    task.id === taskId ? { ...task, completed } : task
                );
                const firstIncomplete = updatedTasks.find(t => !t.completed);
                
                setTasks(updatedTasks);
                
                // Move to first incomplete task
                setCurrentTaskId(firstIncomplete?.id);
                changeIntervalTo(currentInterval ? { mode: currentInterval.type, taskId: firstIncomplete?.id } : null);
            };

            const changeEditingTaskTo = (newTaskId) => {
                // Finish current edit if any
                if (editingTask && editingValue !== undefined) {
                    setTasks(prev => prev.map(task => 
                        task.id === editingTask ? { ...task, name: editingValue } : task
                    ));
                }
                
                // Start new edit or stop editing
                if (newTaskId) {
                    const task = tasks.find(t => t.id === newTaskId);
                    setEditingTask(newTaskId);
                    setEditingValue(task?.name || '');
                } else {
                    setEditingTask(null);
                    setEditingValue('');
                }
            };

            const changeEditingTitleTo = (editing) => {
                if (editing) {
                    setEditingTitle(true);
                    setEditingTitleValue(title || '');
                } else {
                    setEditingTitle(false);
                    setTitle(editingTitleValue);
                    setEditingTitleValue('');
                }
            };

            const decodeState = (stateString) => {
                const state = stateFromString(stateString);
                setTitle(state.title);
                setTasks(state.tasks);
                setCurrentTaskId(state.currentTaskId);
                setCurrentInterval(state.currentInterval || null);
                setCurrentTime(Date.now());
            };

            const encodeState = () => {
                // If not started just return task titles (with title if not default)
                if (!currentInterval && 
                    tasks.every(task => task.Active === 0 && task.Idle === 0 && !task.completed)) {
                    const taskNames = tasks.map(task => task.name).join('\n');
                    return (title && title !== "Task Timer") ? `title: ${title}\n${taskNames}` : taskNames;
                }
                
                const state = { 
                    title,
                    tasks: tasks.map(({position, ...task}) => task), // Strip position fields
                    currentTaskId,
                    currentInterval
                };
                const jsonString = JSON.stringify(state);
                return btoa(jsonString);
            };

            const handleExportOrImport = () => {
                if (importText.trim()) {
                    // Import mode
                    handleImport(importText);
                    setImportText('');
                } else {
                    // Export mode
                    const stateString = encodeState();
                    navigator.clipboard.writeText(stateString);
                    setImportFeedback('Copied to clipboard');
                    setTimeout(() => setImportFeedback(''), 2000);
                }
            };

            const handleImport = (stateString) => {
                try {
                    decodeState(stateString);
                    setImportFeedback('Import succeeded');
                    setTimeout(() => setImportFeedback(''), 2000);
                } catch (error) {
                    setImportFeedback('Import FAILED');
                    setTimeout(() => setImportFeedback(''), 3000);
                }
            };

            const handleKeyDown = (e, taskId) => {
                if (e.key === 'Enter') {
                    const currentTask = tasks.find(t => t.id === taskId);
                    const nextTask = tasks.find(t => t.position > currentTask.position);
                    changeEditingTaskTo(nextTask?.id || null);
                }
            };

            const handleTitleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    changeEditingTitleTo(false);
                    // Move to first task
                    const firstTask = tasks.find(t => t.position === 0);
                    if (firstTask) {
                        changeEditingTaskTo(firstTask.id);
                    }
                }
            };

            const moveTaskTo = (taskId, position) => {
                const currentPosition = tasks.find(t => t.id === currentTaskId)?.position;
                const taskPosition = tasks.find(t => t.id === taskId)?.position;
                
                // Identify tasks that will be displaced (shift down)
                let targetPosition;
                if (position === 'now') {
                    targetPosition = currentPosition;
                } else if (position === 'next') {
                    targetPosition = currentPosition + 1;
                } else if (position === 'sooner') {
                    targetPosition = taskPosition - 1;
                }
                
                const displacedTasks = new Set(
                    tasks.filter(t => t.position >= targetPosition && t.position < taskPosition && t.id !== taskId)
                         .map(t => t.id)
                );
                
                // Step 1: Fade out affected tasks (but not the moving task)
                setReorderingTasks(displacedTasks);
                
                // Step 2: After fade-out completes, move the task
                setTimeout(() => {
                    const newTasks = [...tasks];
                    const [movedTask] = newTasks.splice(taskPosition, 1);
                    
                    if (position === 'now') {
                        newTasks.splice(currentPosition, 0, movedTask);
                        const firstIncomplete = newTasks.find(t => !t.completed);
                        setCurrentTaskId(firstIncomplete?.id);
                    } else if (position === 'next') {
                        newTasks.splice(currentPosition + 1, 0, movedTask);
                    } else if (position === 'sooner') {
                        newTasks.splice(taskPosition - 1, 0, movedTask);
                    }
                    
                    setTasks(updatePositions(newTasks));
                    
                    // Step 3: After move completes, fade affected tasks back in
                    setTimeout(() => {
                        setReorderingTasks(new Set());
                    }, 175);
                }, 175);
            };

            const currentTask = tasks.find(t => t.id === currentTaskId);
            const currentPosition = currentTask?.position ?? 9999;

            return (
                <div className="p-6 max-w-md mx-auto">
                    <div className="flex items-center mb-6">
                        <button 
                            onClick={() => setShowSlots(!showSlots)}
                            className="px-2 py-2 rounded bg-gray-200 mr-3 text-lg leading-none"
                            title="Show saved timers"
                        >
                            ≡
                        </button>
                        {editingTitle ? (
                            <input 
                                ref={handleInputRef}
                                value={editingTitleValue}
                                onChange={e => setEditingTitleValue(e.target.value)}
                                onBlur={() => changeEditingTitleTo(false)}
                                onKeyDown={handleTitleKeyDown}
                                className="text-2xl font-bold bg-transparent border-b-2 border-blue-500 outline-none"
                                autoFocus
                                placeholder="Untitled"
                            />
                        ) : (
                            <h1 
                                className={`text-2xl font-bold cursor-pointer ${title === '' ? 'text-gray-400 italic' : ''}`}
                                onClick={() => changeEditingTitleTo(true)}
                            >
                                {title === '' ? 'Untitled' : title}
                            </h1>
                        )}
                        <div className="ml-auto flex gap-2">
                            <button 
                                onClick={() => changeIntervalTo(null)}
                                className="px-4 py-2 rounded bg-gray-200"
                                disabled={currentTask?.completed}
                            >
                                Freeze
                            </button>
                            <button 
                                onClick={() => {
                                    // Keep title and task names, just reset timers and completion
                                    setTasks(prev => prev.map(task => ({
                                        ...task,
                                        completed: false,
                                        Active: 0,
                                        Idle: 0
                                    })));
                                    setCurrentTaskId(tasks.find(t => t.position === 0)?.id || 1);
                                    setCurrentInterval(null);
                                    setCurrentTime(Date.now());
                                }}
                                className="px-4 py-2 rounded bg-blue-500 text-white"
                            >
                                Reset
                            </button>
                        </div>
                    </div>

                    {/* Slots Popover */}
                    {showSlots && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={() => setShowSlots(false)}>
                            <div className="bg-white rounded-lg p-4 max-w-sm w-full mx-4" onClick={e => e.stopPropagation()}>
                                <h2 className="text-lg font-bold mb-3">Saved Timers</h2>
                                <div className="space-y-2">
                                    {getAllSlots().map(slot => (
                                        <div 
                                            key={slot.id}
                                            onClick={() => switchToSlot(slot.id)}
                                            className={`p-3 border rounded cursor-pointer hover:bg-gray-50 ${currentSlot === slot.id ? 'border-blue-500 bg-blue-50' : ''}`}
                                        >
                                            <div className="flex items-center justify-between">
                                                <span className="font-medium">
                                                    {!slot.data ? 'Task Timer' : 
                                                     slot.data.title === '' ? 'Untitled' : 
                                                     slot.data.title}
                                                </span>
                                                {currentSlot === slot.id && <span className="text-blue-500 text-sm">Current</span>}
                                            </div>
                                            <div className="text-sm text-gray-600">
                                                {(() => {
                                                    if (!slot.data) return 'Task 1';
                                                    
                                                    const currentTask = slot.data.tasks.find(t => t.id === slot.data.currentTaskId);
                                                    if (!currentTask) return 'No current task';
                                                    
                                                    const taskName = currentTask.name || 'Untitled task';
                                                    const interval = slot.data.currentInterval;
                                                    
                                                    if (!interval || interval.taskId !== currentTask.id) {
                                                        return taskName;
                                                    }
                                                    
                                                    // Calculate live time
                                                    let timeValue;
                                                    if (interval.start) {
                                                        // This slot is running - calculate live time from interval start
                                                        const baseTime = currentTask[interval.type];
                                                        const runningTime = currentTime - interval.start;
                                                        timeValue = formatTime(baseTime + runningTime);
                                                    } else {
                                                        // Static saved time
                                                        timeValue = formatTime(currentTask[interval.type]);
                                                    }
                                                    
                                                    const buttonStyle = interval.type === 'Active' 
                                                        ? 'bg-green-500 text-white px-1 rounded text-xs'
                                                        : 'bg-red-500 text-white px-1 rounded text-xs';
                                                    
                                                    return (
                                                        <span>
                                                            {taskName} 
                                                            <span className={`ml-2 ${buttonStyle}`}>
                                                                {interval.type}: {timeValue}
                                                            </span>
                                                        </span>
                                                    );
                                                })()}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                                <div className="mt-4 flex gap-2">
                                    <button 
                                        onClick={() => setShowSlots(false)}
                                        className="flex-1 px-3 py-2 rounded bg-gray-200"
                                    >
                                        Close
                                    </button>
                                    <button 
                                        onClick={() => {
                                            setShowSlots(false);
                                            setTimeout(() => {
                                                if (confirm('Delete ALL app state? This cannot be undone!')) {
                                                    deleteAllAppState();
                                                }
                                            }, 100);
                                        }}
                                        className="px-3 py-2 rounded bg-red-500 text-white text-sm"
                                        title="Delete all saved timers and reset to fresh app state"
                                    >
                                        Delete all app state (!)
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="space-y-3">
                        {tasks.map(task => (
                            <div key={task.id} className={`border rounded p-3 transition-opacity duration-150 ${reorderingTasks.has(task.id) ? 'opacity-0' : 'opacity-100'}`}>
                                <div className="flex items-center gap-4 mb-2">
                                    <input
                                        type="checkbox"
                                        checked={task.completed}
                                        onChange={(e) => completeTask(task.id, e.target.checked)}
                                        className="w-4 h-4"
                                    />
                                    {editingTask === task.id ? (
                                        <input 
                                            ref={handleInputRef}
                                            value={editingValue}
                                            onChange={e => setEditingValue(e.target.value)}
                                            onBlur={() => changeEditingTaskTo(null)}
                                            onKeyDown={e => handleKeyDown(e, task.id)}
                                            autoFocus
                                        />
                                    ) : (
                                        <span 
                                            className={`cursor-pointer ${task.completed ? 'line-through text-gray-500' : task.name ? '' : 'text-gray-400 italic'}`}
                                            onClick={() => changeEditingTaskTo(task.id)}
                                        >
                                            {task.name || 'Untitled task'}
                                        </span>
                                    )}
                                    {task.position === tasks.length - 1 && !task.completed && task.id !== currentTaskId && (
                                        <button 
                                            onClick={() => setTasks(prev => prev.filter(t => t.id !== task.id))}
                                            className="ml-auto text-red-500 text-lg leading-none"
                                        >
                                            ⊖
                                        </button>
                                    )}
                                </div>
                                <div className="text-sm text-gray-600">
                                    {(() => {
                                        const active = getTaskTime(task, 'Active');
                                        const idle = getTaskTime(task, 'Idle');
                                        if (task.id === currentTaskId && !task.completed) {
                                            return (
                                                <div className="flex gap-2">
                                                    <button
                                                        onClick={() => changeIntervalTo({ mode: 'Active', taskId: currentTaskId })}
                                                        className={`px-2 py-1 rounded mr-2 ${currentInterval?.type === 'Active' ? 'bg-green-500 text-white' : 'bg-gray-200'}`}
                                                    >
                                                        Active: <span className={active.isRunning ? 'font-bold' : ''}>{formatTime(active.time)}</span>
                                                    </button>
                                                    <button
                                                        onClick={() => changeIntervalTo({ mode: 'Idle', taskId: currentTaskId })}
                                                        className={`px-2 py-1 rounded mr-2 ${currentInterval?.type === 'Idle' ? 'bg-red-500 text-white' : 'bg-gray-200'}`}
                                                    >
                                                        Idle: <span className={idle.isRunning ? 'font-bold' : ''}>{formatTime(idle.time)}</span>
                                                    </button>
                                                    {currentInterval && (
                                                        <button 
                                                            onClick={() => completeTask(currentTaskId)}
                                                            className="px-2 py-1 rounded bg-blue-500 text-white"
                                                        >
                                                            Done
                                                        </button>
                                                    )}
                                                </div>
                                            );
                                        }
                                        return (
                                            <div className="flex items-center justify-between">
                                                <span>
                                                    Active: <span className={active.isRunning ? 'font-bold' : ''}>{formatTime(active.time)}</span> | 
                                                    Idle: <span className={idle.isRunning ? 'font-bold' : ''}>{formatTime(idle.time)}</span>
                                                     {!currentInterval && task.position > currentPosition && (
                                                         <span className="ml-4">
                                                             {task.position === currentPosition + 1 ? (
                                                                 <button 
                                                                     onClick={() => moveTaskTo(task.id, 'now')}
                                                                     className="px-2 py-1 rounded bg-gray-200 text-xs"
                                                                 >
                                                                     <span className="font-bold text-sm">>></span> Now <span className="font-bold text-sm">>></span>
                                                                 </button>
                                                             ) : (
                                                                 <>
                                                                     <button 
                                                                         onClick={() => moveTaskTo(task.id, 'next')}
                                                                         className={`px-2 py-1 rounded bg-gray-200 text-xs mr-2 ${task.position === currentPosition + 2 ? 'invisible' : ''}`}
                                                                     >
                                                                         <span className="font-bold text-sm">></span> Next
                                                                     </button>
                                                                     {task.position >= currentPosition + 2 && (
                                                                         <button 
                                                                             onClick={() => moveTaskTo(task.id, 'sooner')}
                                                                             className="px-2 py-1 rounded bg-gray-200 text-xs"
                                                                         >
                                                                             <span className="font-bold text-sm">^</span> Sooner
                                                                         </button>
                                                                     )}
                                                                 </>
                                                             )}
                                                         </span>
                                                     )}
                                                </span>
                                            </div>
                                        );
                                    })()}
                                </div>
                                {task.position === tasks.length - 1 && !task.completed && (
                                    <div className="flex justify-end -mt-1">
                                        <button 
                                            onClick={() => setTasks(prev => updatePositions([...prev, { id: Math.max(...prev.map(t => t.id)) + 1, name: 'New Task', completed: false, Active: 0, Idle: 0 }]))}
                                            className="text-green-500 text-lg leading-none"
                                        >
                                            ⊕
                                        </button>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                    
                    <div className="mt-4 pt-3 border-t text-sm text-gray-600">
                        {(() => {
                            const totals = getTotals();
                            return (
                                <div className={totals.allCompleted ? 'font-bold' : ''}>
                                    Total - Active: {formatTime(totals.Active)} | Idle: {formatTime(totals.Idle)}
                                </div>
                            );
                        })()}
                    </div>
                    
                    <div className="mt-4 pt-3 border-t flex gap-4 items-center">
                        <button 
                            onClick={handleExportOrImport}
                            className="px-3 py-1 rounded bg-blue-500 text-white text-sm"
                        >
                            {importText.trim() ? 'Import State' : 'Export State'}
                        </button>
                        <textarea
                            value={importText}
                            onChange={e => setImportText(e.target.value)}
                            placeholder={importFeedback || "To import, paste state string here..."}
                            className="flex-1 px-2 py-1 border rounded text-sm resize-none"
                            rows={1}
                        ></textarea>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<TaskTimer />, document.getElementById('root'));
    </script>
</body>
</html>
