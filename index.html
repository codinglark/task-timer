<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Timer with Chess Clock</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        function TaskTimer() {
            const stateFromTitlesOnly = (titles) => ({
                tasks: titles.map((name, index) => ({
                    id: index + 1, name, completed: false, Active: 0, Idle: 0, position: index
                })),
                currentTaskId: 1,
                currentInterval: null
            });

            const updatePositions = (tasks) => 
                tasks.map((task, index) => ({ ...task, position: index }));

            const stateFromString = (stateString) => {
                const defaultTitles = ['Task 1', 'Task 2', 'Task 3'];
                if (!stateString.trim()) return stateFromTitlesOnly(defaultTitles);
                try {
                    const state = JSON.parse(atob(stateString));
                    return { ...state, tasks: updatePositions(state.tasks) };
                } catch {
                    const taskNames = stateString.split(/[;\n|]/).map(name => name.trim()).filter(name => name !== '');
                    if (taskNames.length === 0 || taskNames.length > 100 || taskNames.some(name => name.length > 512)) throw new Error('Invalid format');
                    return stateFromTitlesOnly(taskNames);
                }
            };

            const [tasks, setTasks] = useState(() => stateFromString('').tasks);
            const [currentTime, setCurrentTime] = useState(Date.now());
            const [editingTask, setEditingTask] = useState(null);
            const [editingValue, setEditingValue] = useState('');
            const [importFeedback, setImportFeedback] = useState('');
            const [importText, setImportText] = useState('');
            const [reorderingTasks, setReorderingTasks] = useState(new Set());
            
            const [currentInterval, setCurrentInterval] = useState(null); // {start: timestamp, type: 'Active'|'Idle', taskId: number}
            const [currentTaskId, setCurrentTaskId] = useState(1);

            // Update current time every 100ms when interval is running  
            useEffect(() => {
                if (!currentInterval) return;
                const timer = setInterval(() => setCurrentTime(Date.now()), 100);
                return () => clearInterval(timer);
            }, [currentInterval]);

            const handleInputRef = useCallback((input) => {
                if (input) {
                    input.select();
                }
            }, []);

            const getTaskTime = (task, mode) => {
                const baseTime = task[mode];
                const isRunning = currentInterval?.taskId === task.id && currentInterval.type === mode;
                const runningTime = isRunning ? currentTime - currentInterval.start : 0;
                return {
                    time: baseTime + runningTime,
                    isRunning
                };
            };

            const getTotals = () => {
                const totals = tasks.reduce((acc, task) => {
                    const active = getTaskTime(task, 'Active');
                    const idle = getTaskTime(task, 'Idle');
                    return {
                        Active: acc.Active + active.time,
                        Idle: acc.Idle + idle.time
                    };
                }, { Active: 0, Idle: 0 });
                
                const allCompleted = tasks.every(task => task.completed);
                return { ...totals, allCompleted };
            };

            const formatTime = (ms) => {
                const seconds = Math.floor(ms / 1000);
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const changeIntervalTo = (newState) => {
                const now = Date.now();
                setCurrentTime(now);
                
                // Skip if same task and mode
                if (currentInterval && newState && 
                    currentInterval.taskId === newState.taskId && 
                    currentInterval.type === newState.mode) {
                    return;
                }
                
                // Close current interval
                if (currentInterval) {
                    const duration = now - currentInterval.start;
                    setTasks(prev => prev.map(task => 
                        task.id === currentInterval.taskId 
                            ? { ...task, [currentInterval.type]: task[currentInterval.type] + duration }
                            : task
                    ));
                }
                
                // Start new interval
                setCurrentInterval(newState && newState.taskId ? {
                    start: now,
                    type: newState.mode,
                    taskId: newState.taskId
                } : null);
            };

            const completeTask = (taskId, completed = true) => {
                // Calculate updated tasks and find first incomplete
                const updatedTasks = tasks.map(task =>
                    task.id === taskId ? { ...task, completed } : task
                );
                const firstIncomplete = updatedTasks.find(t => !t.completed);
                
                setTasks(updatedTasks);
                
                // Move to first incomplete task
                setCurrentTaskId(firstIncomplete?.id);
                changeIntervalTo(currentInterval ? { mode: currentInterval.type, taskId: firstIncomplete?.id } : null);
            };

            const changeEditingTaskTo = (newTaskId) => {
                // Finish current edit if any
                if (editingTask && editingValue !== undefined) {
                    setTasks(prev => prev.map(task => 
                        task.id === editingTask ? { ...task, name: editingValue } : task
                    ));
                }
                
                // Start new edit or stop editing
                if (newTaskId) {
                    const task = tasks.find(t => t.id === newTaskId);
                    setEditingTask(newTaskId);
                    setEditingValue(task?.name || '');
                } else {
                    setEditingTask(null);
                    setEditingValue('');
                }
            };

            const decodeState = (stateString) => {
                const state = stateFromString(stateString);
                setTasks(state.tasks);
                setCurrentTaskId(state.currentTaskId);
                setCurrentInterval(state.currentInterval || null);
                setCurrentTime(Date.now());
            };

            const encodeState = () => {
                // If not started just return task titles 
                if (!currentInterval && 
                    tasks.every(task => task.Active === 0 && task.Idle === 0 && !task.completed)) {
                    return tasks.map(task => task.name).join('\n');
                }
                
                const state = { 
                    tasks: tasks.map(({position, ...task}) => task), // Strip position fields
                    currentTaskId,
                    currentInterval
                };
                const jsonString = JSON.stringify(state);
                return btoa(jsonString);
            };

            const handleExportOrImport = () => {
                if (importText.trim()) {
                    // Import mode
                    handleImport(importText);
                    setImportText('');
                } else {
                    // Export mode
                    const stateString = encodeState();
                    navigator.clipboard.writeText(stateString);
                    setImportFeedback('Copied to clipboard');
                    setTimeout(() => setImportFeedback(''), 2000);
                }
            };

            const handleImport = (stateString) => {
                try {
                    decodeState(stateString);
                    setImportFeedback('Import succeeded');
                    setTimeout(() => setImportFeedback(''), 2000);
                } catch (error) {
                    setImportFeedback('Import FAILED');
                    setTimeout(() => setImportFeedback(''), 3000);
                }
            };

            const handleKeyDown = (e, taskId) => {
                if (e.key === 'Enter') {
                    const currentTask = tasks.find(t => t.id === taskId);
                    const nextTask = tasks.find(t => t.position > currentTask.position);
                    changeEditingTaskTo(nextTask?.id || null);
                }
            };

            const moveTaskTo = (taskId, position) => {
                const currentPosition = tasks.find(t => t.id === currentTaskId)?.position;
                const taskPosition = tasks.find(t => t.id === taskId)?.position;
                
                // Identify tasks that will be displaced (shift down)
                let targetPosition;
                if (position === 'now') {
                    targetPosition = currentPosition;
                } else if (position === 'next') {
                    targetPosition = currentPosition + 1;
                } else if (position === 'sooner') {
                    targetPosition = taskPosition - 1;
                }
                
                const displacedTasks = new Set(
                    tasks.filter(t => t.position >= targetPosition && t.position < taskPosition && t.id !== taskId)
                         .map(t => t.id)
                );
                
                // Step 1: Fade out affected tasks (but not the moving task)
                setReorderingTasks(displacedTasks);
                
                // Step 2: After fade-out completes, move the task
                setTimeout(() => {
                    const newTasks = [...tasks];
                    const [movedTask] = newTasks.splice(taskPosition, 1);
                    
                    if (position === 'now') {
                        newTasks.splice(currentPosition, 0, movedTask);
                        const firstIncomplete = newTasks.find(t => !t.completed);
                        setCurrentTaskId(firstIncomplete?.id);
                    } else if (position === 'next') {
                        newTasks.splice(currentPosition + 1, 0, movedTask);
                    } else if (position === 'sooner') {
                        newTasks.splice(taskPosition - 1, 0, movedTask);
                    }
                    
                    setTasks(updatePositions(newTasks));
                    
                    // Step 3: After move completes, fade affected tasks back in
                    setTimeout(() => {
                        setReorderingTasks(new Set());
                    }, 175);
                }, 175);
            };

            const currentTask = tasks.find(t => t.id === currentTaskId);
            const currentPosition = currentTask?.position ?? 9999;

            return (
                <div className="p-6 max-w-md mx-auto">
                    <div className="flex items-center mb-6">
                        <h1 className="text-2xl font-bold">Task Timer</h1>
                        <div className="ml-auto flex gap-2">
                            <button 
                                onClick={() => changeIntervalTo(null)}
                                className="px-4 py-2 rounded bg-gray-200"
                                disabled={currentTask?.completed}
                            >
                                Freeze
                            </button>
                            <button 
                                onClick={() => decodeState(tasks.map(task => task.name).join('\n'))}
                                className="px-4 py-2 rounded bg-blue-500 text-white"
                            >
                                Reset
                            </button>
                        </div>
                    </div>

                    <div className="space-y-3">
                        {tasks.map(task => (
                            <div key={task.id} className={`border rounded p-3 transition-opacity duration-150 ${reorderingTasks.has(task.id) ? 'opacity-0' : 'opacity-100'}`}>
                                <div className="flex items-center gap-4 mb-2">
                                    <input
                                        type="checkbox"
                                        checked={task.completed}
                                        onChange={(e) => completeTask(task.id, e.target.checked)}
                                        className="w-4 h-4"
                                    />
                                    {editingTask === task.id ? (
                                        <input 
                                            ref={handleInputRef}
                                            value={editingValue}
                                            onChange={e => setEditingValue(e.target.value)}
                                            onBlur={() => changeEditingTaskTo(null)}
                                            onKeyDown={e => handleKeyDown(e, task.id)}
                                            autoFocus
                                        />
                                    ) : (
                                        <span 
                                            className={`cursor-pointer ${task.completed ? 'line-through text-gray-500' : task.name ? '' : 'text-gray-400 italic'}`}
                                            onClick={() => changeEditingTaskTo(task.id)}
                                        >
                                            {task.name || 'Untitled task'}
                                        </span>
                                    )}
                                    {task.position === tasks.length - 1 && !task.completed && task.id !== currentTaskId && (
                                        <button 
                                            onClick={() => setTasks(prev => prev.filter(t => t.id !== task.id))}
                                            className="ml-auto text-red-500 text-lg leading-none"
                                        >
                                            ⊖
                                        </button>
                                    )}
                                </div>
                                <div className="text-sm text-gray-600">
                                    {(() => {
                                        const active = getTaskTime(task, 'Active');
                                        const idle = getTaskTime(task, 'Idle');
                                        if (task.id === currentTaskId && !task.completed) {
                                            return (
                                                <div className="flex gap-2">
                                                    <button
                                                        onClick={() => changeIntervalTo({ mode: 'Active', taskId: currentTaskId })}
                                                        className={`px-2 py-1 rounded mr-2 ${currentInterval?.type === 'Active' ? 'bg-green-500 text-white' : 'bg-gray-200'}`}
                                                    >
                                                        Active: <span className={active.isRunning ? 'font-bold' : ''}>{formatTime(active.time)}</span>
                                                    </button>
                                                    <button
                                                        onClick={() => changeIntervalTo({ mode: 'Idle', taskId: currentTaskId })}
                                                        className={`px-2 py-1 rounded mr-2 ${currentInterval?.type === 'Idle' ? 'bg-red-500 text-white' : 'bg-gray-200'}`}
                                                    >
                                                        Idle: <span className={idle.isRunning ? 'font-bold' : ''}>{formatTime(idle.time)}</span>
                                                    </button>
                                                    {currentInterval && (
                                                        <button 
                                                            onClick={() => completeTask(currentTaskId)}
                                                            className="px-2 py-1 rounded bg-blue-500 text-white"
                                                        >
                                                            Done
                                                        </button>
                                                    )}
                                                </div>
                                            );
                                        }
                                        return (
                                            <div className="flex items-center justify-between">
                                                <span>
                                                    Active: <span className={active.isRunning ? 'font-bold' : ''}>{formatTime(active.time)}</span> | 
                                                    Idle: <span className={idle.isRunning ? 'font-bold' : ''}>{formatTime(idle.time)}</span>
                                                     {!currentInterval && task.position > currentPosition && (
                                                         <span className="ml-4">
                                                             {task.position === currentPosition + 1 ? (
                                                                 <button 
                                                                     onClick={() => moveTaskTo(task.id, 'now')}
                                                                     className="px-2 py-1 rounded bg-gray-200 text-xs"
                                                                 >
                                                                     <span className="font-bold text-sm">>></span> Now <span className="font-bold text-sm">>></span>
                                                                 </button>
                                                             ) : (
                                                                 <>
                                                                     <button 
                                                                         onClick={() => moveTaskTo(task.id, 'next')}
                                                                         className={`px-2 py-1 rounded bg-gray-200 text-xs mr-2 ${task.position === currentPosition + 2 ? 'invisible' : ''}`}
                                                                     >
                                                                         <span className="font-bold text-sm">></span> Next
                                                                     </button>
                                                                     {task.position >= currentPosition + 2 && (
                                                                         <button 
                                                                             onClick={() => moveTaskTo(task.id, 'sooner')}
                                                                             className="px-2 py-1 rounded bg-gray-200 text-xs"
                                                                         >
                                                                             <span className="font-bold text-sm">^</span> Sooner
                                                                         </button>
                                                                     )}
                                                                 </>
                                                             )}
                                                         </span>
                                                     )}
                                                </span>
                                            </div>
                                        );
                                    })()}
                                </div>
                                {task.position === tasks.length - 1 && !task.completed && (
                                    <div className="flex justify-end -mt-1">
                                        <button 
                                            onClick={() => setTasks(prev => updatePositions([...prev, { id: Math.max(...prev.map(t => t.id)) + 1, name: 'New Task', completed: false, Active: 0, Idle: 0 }]))}
                                            className="text-green-500 text-lg leading-none"
                                        >
                                            ⊕
                                        </button>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                    
                    <div className="mt-4 pt-3 border-t text-sm text-gray-600">
                        {(() => {
                            const totals = getTotals();
                            return (
                                <div className={totals.allCompleted ? 'font-bold' : ''}>
                                    Total - Active: {formatTime(totals.Active)} | Idle: {formatTime(totals.Idle)}
                                </div>
                            );
                        })()}
                    </div>
                    
                    <div className="mt-4 pt-3 border-t flex gap-4 items-center">
                        <button 
                            onClick={handleExportOrImport}
                            className="px-3 py-1 rounded bg-blue-500 text-white text-sm"
                        >
                            {importText.trim() ? 'Import State' : 'Export State'}
                        </button>
                        <textarea
                            value={importText}
                            onChange={e => setImportText(e.target.value)}
                            placeholder={importFeedback || "To import, paste state string here..."}
                            className="flex-1 px-2 py-1 border rounded text-sm resize-none"
                            rows={1}
                        ></textarea>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<TaskTimer />, document.getElementById('root'));
    </script>
</body>
</html>
